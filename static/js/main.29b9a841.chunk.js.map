{"version":3,"sources":["Components/ChannelForm/ChannelForm.js","Components/Call/Call.js","App.js","serviceWorker.js","index.js"],"names":["ChannelForm","props","onChange","e","target","name","value","setState","disabled","state","onSubmit","alert","preventDefault","console","log","channel","selectChannel","this","placeholder","type","Component","client","AgoraRTC","createClient","mode","codec","APP_ID","USER_ID","Math","floor","random","Call","localStream","createStream","streamID","audio","video","screen","remoteStreams","joinChannel","me","join","uid","publish","err","on","evt","initLocalStream","init","play","subscribeToClient","onStreamAdded","onRemoteClientAdded","onStreamRemoved","onPeerLeave","stream","getId","remoteStream","subscribe","streamId","stop","initClient","prevProps","prevState","id","style","width","height","Object","keys","map","key","App","className","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.29b9a841.chunk.js","sourcesContent":["// ChannelForm.js\nimport React, { Component } from \"react\";\nimport '../ChannelForm/ChannelForm.css'\n\n\nexport default class ChannelForm extends Component {\n// ChannelForm.js\nconstructor(props) {\n  super(props);\n  this.state = {\n    channel: \"\",\n    disabled:true\n  };\n}\n\n\nonChange = e => {\n  let { name, value } = e.target;\n  this.setState({ [name]: value });\n  if(value === \"catorcetest\"){\n    this.setState({disabled:!this.state.disabled})\n  }\n};\n\nonSubmit = e => {\n  alert(\"si\")\n  e.preventDefault();\n  console.log(\"Submiting \", this.state.channel);\n  this.props.selectChannel(this.state.channel);\n  this.setState({ channel: \"\" });\n};\n\nrender(props) {\n\n  return (\n    <div>\n      <form onSubmit={this.onSubmit}>\n        <label>Channel Name</label>\n        <input placeholder=\"Nombre del Canal\" name=\"channel\"\n            value={this.state.channel}\n            onChange={this.onChange} />\n            <input type=\"submit\" disabled={this.state.disabled} value=\"CatorceTest\" />\n      </form>\n    </div>\n  );\n}\n}","import React, { Component } from \"react\";\n\nimport AgoraRTC from \"agora-rtc-sdk\";\n\nimport '../Call/Call.css'\n\nlet client = AgoraRTC.createClient({ mode: \"live\", codec: \"h264\" });\n\nconst APP_ID = \"fe96d319a7bf449cab5d83778c71b7e8\";\nconst USER_ID = Math.floor(Math.random() * 1000000001);\n\nexport default class Call extends Component {\n  localStream = AgoraRTC.createStream({\n    streamID: USER_ID,\n    audio: true,\n    video: true,\n    screen: false\n  });\n\n  state = {\n    remoteStreams: {}\n  };\n\n  componentDidMount() {\n    this.initLocalStream();\n    this.initClient();\n  }\n  componentDidUpdate(prevProps, prevState) {\n    console.log(\"MIRARARARA\")\n    if (prevProps.channel !== this.props.channel && this.props.channel !== \"\") {\n      this.joinChannel();\n    }\n  }\n  joinChannel = () => {\n    let me = this;\n    client.join(\n      null,\n      me.props.channel,\n      USER_ID,\n      function(uid) {\n        console.log(\"User \" + uid + \" join channel successfully\");\n        client.publish(me.localStream, function(err) {\n          console.log(\"Publish local stream error: \" + err);\n        });\n\n        client.on(\"stream-published\", function(evt) {\n          console.log(\"Publish local stream successfully\");\n        });\n      },\n      function(err) {\n        console.log(\"Join channel failed\", err);\n      }\n    );\n  };\n  initLocalStream = () => {\n    let me = this;\n    me.localStream.init(\n      function() {\n        console.log(\"getUserMedia successfully\");\n        me.localStream.play(\"agora_local\");\n      },\n      function(err) {\n        console.log(\"getUserMedia failed\", err);\n      }\n    );\n  };\n  subscribeToClient = () => {\n    let me = this;\n    console.log(this.onStreamAdded)\n    client.on(\"stream-added\", me.onStreamAdded);\n    client.on(\"stream-subscribed\", me.onRemoteClientAdded);\n    client.on(\"stream-removed\", me.onStreamRemoved);\n    client.on(\"peer-leave\", me.onPeerLeave);\n  };\n  onStreamAdded = evt => {\n    let me = this;\n    let stream = evt.stream;\n    console.log(\"New stream added: \" + stream.getId());\n    me.setState(\n      {\n        remoteStreams: {\n          ...me.state.remoteStream,\n          [stream.getId()]: stream\n        }\n      },\n      () => {\n        // Subscribe after new remoteStreams state set to make sure\n        // new stream dom el has been rendered for agora.io sdk to pick up\n        client.subscribe(stream, function(err) {\n          console.log(\"Subscribe stream failed\", err);\n        });\n      }\n    );\n  };\n  onStreamRemoved = evt => {\n    let me = this;\n    let stream = evt.stream;\n    if (stream) {\n      let streamId = stream.getId();\n      let { remoteStreams } = me.state;\n\n      stream.stop();\n      delete remoteStreams[streamId];\n\n      me.setState({ remoteStreams });\n\n      console.log(\"Remote stream is removed \" + stream.getId());\n    }\n  };\n  onRemoteClientAdded = evt => {\n    console.log(\"HOLA\")\n    let me = this;\n    let remoteStream = evt.stream;\n    me.state.remoteStreams[remoteStream.getId()].play(\n      \"agora_remote \" + remoteStream.getId()\n    );\n  };\n  onPeerLeave = evt => {\n    let me = this;\n    let stream = evt.stream;\n    if (stream) {\n      let streamId = stream.getId();\n      let { remoteStreams } = me.state;\n\n      stream.stop();\n      delete remoteStreams[streamId];\n\n      me.setState({ remoteStreams });\n\n      console.log(\"Remote stream is removed \" + stream.getId());\n    }\n  };\n  initClient = () => {\n    client.init(\n      APP_ID,\n      function() {\n        console.log(\"AgoraRTC client initialized\");\n      },\n      function(err) {\n        console.log(\"AgoraRTC client init failed\", err);\n      }\n    );\n    this.subscribeToClient();\n  };\n  render() {\n    return (\n      <div>\n        <div id=\"agora_local\" style={{ width: \"400px\", height: \"400px\" }} />\n        {Object.keys(this.state.remoteStreams).map(key => {\n          let stream = this.state.remoteStreams[key];\n          let streamId = stream.getId();\n          return (\n            <div\n              key={streamId}\n              id={`agora_remote ${streamId}`}\n              style={{ width: \"400px\", height: \"400px\" }}\n            />\n          );\n        })}\n      </div>\n    );\n  }\n}","// App.js\nimport React, { Component } from \"react\";\nimport ChannelForm from \"./Components/ChannelForm/ChannelForm\";\nimport Call from './Components/Call/Call'\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      channel: ''\n    }\n  }\n\n  selectChannel = channel => {\n    this.setState({ channel });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <ChannelForm selectChannel={this.selectChannel} />\n        <Call channel={this.state.channel}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}